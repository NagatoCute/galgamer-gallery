---
---

<body>
<canvas id="mainCanvas"></canvas>
</body>

<script type="module">
    import * as THREE from 'https://cdn.skypack.dev/three@0.130.0';

    // 场景管理器类
    class SceneManager {
        constructor() {
            this.scene = new THREE.Scene();
            this.scene.background = new THREE.Color(0xffffff);

            this.renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById("mainCanvas"),
                antialias: true,
                alpha: true
            });
            this.renderer.setSize(window.innerWidth, window.innerHeight);

            this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            this.camera.position.set(0, 10, 30);

            this.setupLights();
            this.setupEventListeners();
        }

        setupLights() {
            const ambientLight = new THREE.AmbientLight(0x606060);
            this.scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xBCD2EE);
            directionalLight.position.set(1, 0.75, 0.5).normalize();
            this.scene.add(directionalLight);
        }

        setupEventListeners() {
            window.addEventListener('resize', () => {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        render() {
            this.renderer.render(this.scene, this.camera);
        }
    }

    // 相机控制器类
    class CameraController {
        constructor(camera) {
            this.camera = camera;
            this.leftPress = false;
            this.front = false;
            this.mashiro = false;
            this.left = false;
            this.right = false;

            this.setupEventListeners();
        }

        setupEventListeners() {
            window.addEventListener('mousemove', this.handleMouseMove.bind(this));
            window.addEventListener('mousedown', () => this.leftPress = true);
            window.addEventListener('mouseup', () => this.leftPress = false);
            window.addEventListener('keydown', this.handleKeyDown.bind(this));
            window.addEventListener('keyup', this.handleKeyUp.bind(this));
        }

        handleMouseMove(event) {
            if (this.leftPress) {
                this.camera.rotateOnWorldAxis(
                    new THREE.Vector3(0, 1, 0),
                    event.movementX / 500
                );
                this.camera.rotateOnAxis(
                    new THREE.Vector3(1, 0, 0),
                    event.movementY / 500
                );
            }
        }

        handleKeyDown(event) {
            switch (event.key.toLowerCase()) {
                case 'w': this.front = true; break;
                case 's': this.mashiro = true; break;
                case 'a': this.left = true; break;
                case 'd': this.right = true; break;
            }
        }

        handleKeyUp(event) {
            switch (event.key.toLowerCase()) {
                case 'w': this.front = false; break;
                case 's': this.mashiro = false; break;
                case 'a': this.left = false; break;
                case 'd': this.right = false; break;
            }
        }

        update() {
            let vect = this.camera.getWorldDirection(new THREE.Vector3());

            if (this.front) {
                this.camera.position.z += vect.dot(new THREE.Vector3(0, 0, 15)) * 0.01;
                this.camera.position.x += vect.dot(new THREE.Vector3(15, 0, 0)) * 0.01;
            }
            if (this.mashiro) {
                this.camera.position.z -= vect.dot(new THREE.Vector3(0, 0, 15)) * 0.01;
                this.camera.position.x -= vect.dot(new THREE.Vector3(15, 0, 0)) * 0.01;
            }
            if (this.left) {
                let rightVect = new THREE.Vector3(1, 0, 0).applyQuaternion(this.camera.quaternion);
                this.camera.position.x -= rightVect.x * 0.1;
                this.camera.position.z -= rightVect.z * 0.1;
            }
            if (this.right) {
                let rightVect = new THREE.Vector3(1, 0, 0).applyQuaternion(this.camera.quaternion);
                this.camera.position.x += rightVect.x * 0.1;
                this.camera.position.z += rightVect.z * 0.1;
            }

            const leftWallX = -50;
            const rightWallX = 50;
            this.camera.position.x = Math.max(leftWallX + 5, Math.min(rightWallX - 5, this.camera.position.x));
        }
    }

    // 画框类
    class Frame {
        constructor(scene, imageUrl, position, dimensions) {
            this.scene = scene;
            this.imageUrl = imageUrl;
            this.position = position;
            this.dimensions = dimensions;
            this.mesh = this.createFrame();
        }

        createFrame() {
            const geometry = new THREE.PlaneGeometry(this.dimensions.width, this.dimensions.height);
            const texture = new THREE.TextureLoader().load(this.imageUrl);
            const material = new THREE.MeshBasicMaterial({map: texture, side: THREE.DoubleSide});
            const frame = new THREE.Mesh(geometry, material);

            frame.position.set(this.position.x, this.position.y, this.position.z);
            frame.rotation.y = Math.PI / 2;
            frame.scale.x = -1;

            return frame;
        }
    }

    // 画廊类
    class Gallery {
        constructor(scene) {
            this.scene = scene;
            this.framesGroup = new THREE.Group();
            this.scene.add(this.framesGroup);

            this.imageWidth = 600;
            this.imageHeight = 1080;
            this.frameCount = 7;

            this.createFrames();
        }

        createFrames() {
            const frameWidth = 9;
            const frameHeight = 15;
            const spacing = 3;

            const totalWidth = (frameWidth + spacing) * this.frameCount - spacing;
            const startZ = -totalWidth / 2;

            for (let i = 0; i < this.frameCount; i++) {
                const imageUrl = `https://placehold.co/${this.imageWidth}x${this.imageHeight}/jpg`;
                const positionZ = startZ + i * (frameWidth + spacing);

                const frame = new Frame(
                    this.scene,
                    imageUrl,
                    { x: 50, y: 10, z: positionZ },
                    { width: frameWidth, height: frameHeight }
                );

                this.framesGroup.add(frame.mesh);
            }
        }
    }

    // 场景辅助工具类
    class SceneHelper {
        constructor(scene) {
            this.scene = scene;
            this.addGrid();
            this.addAxes();
            this.addWallGrids();
        }

        addGrid() {
            const grid = new THREE.GridHelper(100, 20, 0xFF0000, 0x000000);
            grid.material.opacity = 0.1;
            grid.material.transparent = true;
            this.scene.add(grid);
        }

        addAxes() {
            const axesHelper = new THREE.AxesHelper(30);
            this.scene.add(axesHelper);
        }

        addWallGrids() {
            const leftWallGrid = new THREE.GridHelper(100, 20, 0x00FF00, 0x000000);
            leftWallGrid.material.opacity = 0.3;
            leftWallGrid.material.transparent = true;
            leftWallGrid.position.set(-50, 50, 0);
            leftWallGrid.rotation.z = Math.PI / 2;
            this.scene.add(leftWallGrid);

            const rightWallGrid = new THREE.GridHelper(100, 20, 0x00FF00, 0x000000);
            rightWallGrid.material.opacity = 0.3;
            rightWallGrid.material.transparent = true;
            rightWallGrid.position.set(50, 50, 0);
            rightWallGrid.rotation.z = Math.PI / 2;
            this.scene.add(rightWallGrid);
        }
    }

    // 主应用类
    class App {
        constructor() {
            this.sceneManager = new SceneManager();
            this.cameraController = new CameraController(this.sceneManager.camera);
            this.helper = new SceneHelper(this.sceneManager.scene);
            this.gallery = new Gallery(this.sceneManager.scene);

            this.animate();
        }

        animate() {
            requestAnimationFrame(this.animate.bind(this));
            this.cameraController.update();
            this.sceneManager.render();
        }
    }

    // 初始化应用
    new App();
</script>